{"ast":null,"code":"import { PointerType } from \"../PointerType\";\nexport function isPointerInBounds(view, _ref) {\n  var x = _ref.x,\n    y = _ref.y;\n  var rect = view.getBoundingClientRect();\n  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n}\nexport var PointerTypeMapping = new Map([['mouse', PointerType.MOUSE], ['touch', PointerType.TOUCH], ['pen', PointerType.STYLUS], ['none', PointerType.OTHER]]);\nexport var degToRad = function degToRad(degrees) {\n  return degrees * Math.PI / 180;\n};\nexport var coneToDeviation = function coneToDeviation(degrees) {\n  return Math.cos(degToRad(degrees / 2));\n};\nexport function calculateViewScale(view) {\n  var _RegExp$exec;\n  var styles = getComputedStyle(view);\n  var resultScales = {\n    scaleX: 1,\n    scaleY: 1\n  };\n  if (styles.scale !== undefined && styles.scale !== 'none') {\n    var scales = styles.scale.split(' ');\n    if (scales[0]) {\n      resultScales.scaleX = parseFloat(scales[0]);\n    }\n    resultScales.scaleY = scales[1] ? parseFloat(scales[1]) : parseFloat(scales[0]);\n  }\n  var matrixElements = (_RegExp$exec = new RegExp(/matrix\\((.+)\\)/).exec(styles.transform)) === null || _RegExp$exec === void 0 ? void 0 : _RegExp$exec[1];\n  if (matrixElements) {\n    var matrixElementsArray = matrixElements.split(', ');\n    resultScales.scaleX *= parseFloat(matrixElementsArray[0]);\n    resultScales.scaleY *= parseFloat(matrixElementsArray[3]);\n  }\n  return resultScales;\n}\nexport function tryExtractStylusData(event) {\n  var pointerType = PointerTypeMapping.get(event.pointerType);\n  if (pointerType !== PointerType.STYLUS) {\n    return;\n  }\n  var eventAzimuthAngle = event.azimuthAngle;\n  var eventAltitudeAngle = event.altitudeAngle;\n  if (event.tiltX === 0 && event.tiltY === 0) {\n    if (eventAzimuthAngle === undefined || eventAltitudeAngle === undefined) {\n      return {\n        tiltX: 0,\n        tiltY: 0,\n        azimuthAngle: Math.PI / 2,\n        altitudeAngle: Math.PI / 2,\n        pressure: event.pressure\n      };\n    }\n    var _spherical2tilt = spherical2tilt(eventAltitudeAngle, eventAzimuthAngle),\n      tiltX = _spherical2tilt.tiltX,\n      tiltY = _spherical2tilt.tiltY;\n    return {\n      tiltX: tiltX,\n      tiltY: tiltY,\n      azimuthAngle: eventAzimuthAngle,\n      altitudeAngle: eventAltitudeAngle,\n      pressure: event.pressure\n    };\n  }\n  var _tilt2spherical = tilt2spherical(event.tiltX, event.tiltY),\n    altitudeAngle = _tilt2spherical.altitudeAngle,\n    azimuthAngle = _tilt2spherical.azimuthAngle;\n  return {\n    tiltX: event.tiltX,\n    tiltY: event.tiltY,\n    azimuthAngle: azimuthAngle,\n    altitudeAngle: altitudeAngle,\n    pressure: event.pressure\n  };\n}\nfunction tilt2spherical(tiltX, tiltY) {\n  var tiltXrad = tiltX * Math.PI / 180;\n  var tiltYrad = tiltY * Math.PI / 180;\n  var azimuthAngle = 0;\n  if (tiltX === 0) {\n    if (tiltY > 0) {\n      azimuthAngle = Math.PI / 2;\n    } else if (tiltY < 0) {\n      azimuthAngle = 3 * Math.PI / 2;\n    }\n  } else if (tiltY === 0) {\n    if (tiltX < 0) {\n      azimuthAngle = Math.PI;\n    }\n  } else if (Math.abs(tiltX) === 90 || Math.abs(tiltY) === 90) {\n    azimuthAngle = 0;\n  } else {\n    var tanX = Math.tan(tiltXrad);\n    var tanY = Math.tan(tiltYrad);\n    azimuthAngle = Math.atan2(tanY, tanX);\n    if (azimuthAngle < 0) {\n      azimuthAngle += 2 * Math.PI;\n    }\n  }\n  var altitudeAngle = 0;\n  if (Math.abs(tiltX) === 90 || Math.abs(tiltY) === 90) {\n    altitudeAngle = 0;\n  } else if (tiltX === 0) {\n    altitudeAngle = Math.PI / 2 - Math.abs(tiltYrad);\n  } else if (tiltY === 0) {\n    altitudeAngle = Math.PI / 2 - Math.abs(tiltXrad);\n  } else {\n    altitudeAngle = Math.atan(1.0 / Math.sqrt(Math.pow(Math.tan(tiltXrad), 2) + Math.pow(Math.tan(tiltYrad), 2)));\n  }\n  return {\n    altitudeAngle: altitudeAngle,\n    azimuthAngle: azimuthAngle\n  };\n}\nfunction spherical2tilt(altitudeAngle, azimuthAngle) {\n  var radToDeg = 180 / Math.PI;\n  var tiltXrad = 0;\n  var tiltYrad = 0;\n  if (altitudeAngle === 0) {\n    if (azimuthAngle === 0 || azimuthAngle === 2 * Math.PI) {\n      tiltXrad = Math.PI / 2;\n    }\n    if (azimuthAngle === Math.PI / 2) {\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle === Math.PI) {\n      tiltXrad = -Math.PI / 2;\n    }\n    if (azimuthAngle === 3 * Math.PI / 2) {\n      tiltYrad = -Math.PI / 2;\n    }\n    if (azimuthAngle > 0 && azimuthAngle < Math.PI / 2) {\n      tiltXrad = Math.PI / 2;\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle > Math.PI / 2 && azimuthAngle < Math.PI) {\n      tiltXrad = -Math.PI / 2;\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle > Math.PI && azimuthAngle < 3 * Math.PI / 2) {\n      tiltXrad = -Math.PI / 2;\n      tiltYrad = -Math.PI / 2;\n    }\n    if (azimuthAngle > 3 * Math.PI / 2 && azimuthAngle < 2 * Math.PI) {\n      tiltXrad = Math.PI / 2;\n      tiltYrad = -Math.PI / 2;\n    }\n  }\n  if (altitudeAngle !== 0) {\n    var tanAlt = Math.tan(altitudeAngle);\n    tiltXrad = Math.atan(Math.cos(azimuthAngle) / tanAlt);\n    tiltYrad = Math.atan(Math.sin(azimuthAngle) / tanAlt);\n  }\n  var tiltX = Math.round(tiltXrad * radToDeg);\n  var tiltY = Math.round(tiltYrad * radToDeg);\n  return {\n    tiltX: tiltX,\n    tiltY: tiltY\n  };\n}\nvar RNSVGElements = ['Circle', 'ClipPath', 'Ellipse', 'ForeignObject', 'G', 'Image', 'Line', 'Marker', 'Mask', 'Path', 'Pattern', 'Polygon', 'Polyline', 'Rect', 'Svg', 'Symbol', 'TSpan', 'Text', 'TextPath', 'Use'];\nexport function isRNSVGElement(viewRef) {\n  var componentClassName = Object.getPrototypeOf(viewRef).constructor.name;\n  return RNSVGElements.indexOf(componentClassName) >= 0 && Object.hasOwn(viewRef, 'elementRef');\n}","map":{"version":3,"names":["PointerType","isPointerInBounds","view","_ref","x","y","rect","getBoundingClientRect","left","right","top","bottom","PointerTypeMapping","Map","MOUSE","TOUCH","STYLUS","OTHER","degToRad","degrees","Math","PI","coneToDeviation","cos","calculateViewScale","_RegExp$exec","styles","getComputedStyle","resultScales","scaleX","scaleY","scale","undefined","scales","split","parseFloat","matrixElements","RegExp","exec","transform","matrixElementsArray","tryExtractStylusData","event","pointerType","get","eventAzimuthAngle","azimuthAngle","eventAltitudeAngle","altitudeAngle","tiltX","tiltY","pressure","_spherical2tilt","spherical2tilt","_tilt2spherical","tilt2spherical","tiltXrad","tiltYrad","abs","tanX","tan","tanY","atan2","atan","sqrt","pow","radToDeg","tanAlt","sin","round","RNSVGElements","isRNSVGElement","viewRef","componentClassName","Object","getPrototypeOf","constructor","name","indexOf","hasOwn"],"sources":["f:\\Coding\\Code\\SKiddy V2\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\utils.ts"],"sourcesContent":["import { PointerType } from '../PointerType';\nimport type {\n  GestureHandlerRef,\n  Point,\n  StylusData,\n  SVGRef,\n} from './interfaces';\n\nexport function isPointerInBounds(view: HTMLElement, { x, y }: Point): boolean {\n  const rect: DOMRect = view.getBoundingClientRect();\n\n  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n}\n\nexport const PointerTypeMapping = new Map<string, PointerType>([\n  ['mouse', PointerType.MOUSE],\n  ['touch', PointerType.TOUCH],\n  ['pen', PointerType.STYLUS],\n  ['none', PointerType.OTHER],\n]);\n\nexport const degToRad = (degrees: number) => (degrees * Math.PI) / 180;\n\nexport const coneToDeviation = (degrees: number) =>\n  Math.cos(degToRad(degrees / 2));\n\nexport function calculateViewScale(view: HTMLElement) {\n  const styles = getComputedStyle(view);\n\n  const resultScales = {\n    scaleX: 1,\n    scaleY: 1,\n  };\n\n  // Get scales from scale property\n  if (styles.scale !== undefined && styles.scale !== 'none') {\n    const scales = styles.scale.split(' ');\n\n    if (scales[0]) {\n      resultScales.scaleX = parseFloat(scales[0]);\n    }\n\n    resultScales.scaleY = scales[1]\n      ? parseFloat(scales[1])\n      : parseFloat(scales[0]);\n  }\n\n  // Get scales from transform property\n  const matrixElements = new RegExp(/matrix\\((.+)\\)/).exec(\n    styles.transform\n  )?.[1];\n\n  if (matrixElements) {\n    const matrixElementsArray = matrixElements.split(', ');\n\n    resultScales.scaleX *= parseFloat(matrixElementsArray[0]);\n    resultScales.scaleY *= parseFloat(matrixElementsArray[3]);\n  }\n\n  return resultScales;\n}\n\nexport function tryExtractStylusData(\n  event: PointerEvent\n): StylusData | undefined {\n  const pointerType = PointerTypeMapping.get(event.pointerType);\n\n  if (pointerType !== PointerType.STYLUS) {\n    return;\n  }\n\n  // @ts-ignore This property exists (https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent#instance_properties)\n  const eventAzimuthAngle: number | undefined = event.azimuthAngle;\n  // @ts-ignore This property exists (https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent#instance_properties)\n  const eventAltitudeAngle: number | undefined = event.altitudeAngle;\n\n  if (event.tiltX === 0 && event.tiltY === 0) {\n    // If we are in this branch, it means that either tilt properties are not supported and we have to calculate them from altitude and azimuth angles,\n    // or stylus is perpendicular to the screen and we can use altitude / azimuth instead of tilt\n\n    // If azimuth and altitude are undefined in this branch, it means that we are either perpendicular to the screen,\n    // or that none of the position sets is supported. In that case, we can treat stylus as perpendicular\n    if (eventAzimuthAngle === undefined || eventAltitudeAngle === undefined) {\n      return {\n        tiltX: 0,\n        tiltY: 0,\n        azimuthAngle: Math.PI / 2,\n        altitudeAngle: Math.PI / 2,\n        pressure: event.pressure,\n      };\n    }\n\n    const { tiltX, tiltY } = spherical2tilt(\n      eventAltitudeAngle,\n      eventAzimuthAngle\n    );\n\n    return {\n      tiltX,\n      tiltY,\n      azimuthAngle: eventAzimuthAngle,\n      altitudeAngle: eventAltitudeAngle,\n      pressure: event.pressure,\n    };\n  }\n\n  const { altitudeAngle, azimuthAngle } = tilt2spherical(\n    event.tiltX,\n    event.tiltY\n  );\n\n  return {\n    tiltX: event.tiltX,\n    tiltY: event.tiltY,\n    azimuthAngle,\n    altitudeAngle,\n    pressure: event.pressure,\n  };\n}\n\n// `altitudeAngle` and `azimuthAngle` are experimental properties, which are not supported on Firefox and Safari.\n// Given that, we use `tilt` properties and algorithm that converts one value to another.\n//\n// Source: https://w3c.github.io/pointerevents/#converting-between-tiltx-tilty-and-altitudeangle-azimuthangle\nfunction tilt2spherical(tiltX: number, tiltY: number) {\n  const tiltXrad = (tiltX * Math.PI) / 180;\n  const tiltYrad = (tiltY * Math.PI) / 180;\n\n  // calculate azimuth angle\n  let azimuthAngle = 0;\n\n  if (tiltX === 0) {\n    if (tiltY > 0) {\n      azimuthAngle = Math.PI / 2;\n    } else if (tiltY < 0) {\n      azimuthAngle = (3 * Math.PI) / 2;\n    }\n  } else if (tiltY === 0) {\n    if (tiltX < 0) {\n      azimuthAngle = Math.PI;\n    }\n  } else if (Math.abs(tiltX) === 90 || Math.abs(tiltY) === 90) {\n    // not enough information to calculate azimuth\n    azimuthAngle = 0;\n  } else {\n    // Non-boundary case: neither tiltX nor tiltY is equal to 0 or +-90\n    const tanX = Math.tan(tiltXrad);\n    const tanY = Math.tan(tiltYrad);\n\n    azimuthAngle = Math.atan2(tanY, tanX);\n    if (azimuthAngle < 0) {\n      azimuthAngle += 2 * Math.PI;\n    }\n  }\n\n  // calculate altitude angle\n  let altitudeAngle = 0;\n\n  if (Math.abs(tiltX) === 90 || Math.abs(tiltY) === 90) {\n    altitudeAngle = 0;\n  } else if (tiltX === 0) {\n    altitudeAngle = Math.PI / 2 - Math.abs(tiltYrad);\n  } else if (tiltY === 0) {\n    altitudeAngle = Math.PI / 2 - Math.abs(tiltXrad);\n  } else {\n    // Non-boundary case: neither tiltX nor tiltY is equal to 0 or +-90\n    altitudeAngle = Math.atan(\n      1.0 /\n        Math.sqrt(\n          Math.pow(Math.tan(tiltXrad), 2) + Math.pow(Math.tan(tiltYrad), 2)\n        )\n    );\n  }\n\n  return { altitudeAngle: altitudeAngle, azimuthAngle: azimuthAngle };\n}\n\n// If we are on a platform that doesn't support `tiltX` and `tiltY`, we have to calculate them from `altitude` and `azimuth` angles.\n//\n// Source: https://w3c.github.io/pointerevents/#converting-between-tiltx-tilty-and-altitudeangle-azimuthangle\nfunction spherical2tilt(altitudeAngle: number, azimuthAngle: number) {\n  const radToDeg = 180 / Math.PI;\n\n  let tiltXrad = 0;\n  let tiltYrad = 0;\n\n  if (altitudeAngle === 0) {\n    // the pen is in the X-Y plane\n    if (azimuthAngle === 0 || azimuthAngle === 2 * Math.PI) {\n      // pen is on positive X axis\n      tiltXrad = Math.PI / 2;\n    }\n    if (azimuthAngle === Math.PI / 2) {\n      // pen is on positive Y axis\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle === Math.PI) {\n      // pen is on negative X axis\n      tiltXrad = -Math.PI / 2;\n    }\n    if (azimuthAngle === (3 * Math.PI) / 2) {\n      // pen is on negative Y axis\n      tiltYrad = -Math.PI / 2;\n    }\n    if (azimuthAngle > 0 && azimuthAngle < Math.PI / 2) {\n      tiltXrad = Math.PI / 2;\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle > Math.PI / 2 && azimuthAngle < Math.PI) {\n      tiltXrad = -Math.PI / 2;\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle > Math.PI && azimuthAngle < (3 * Math.PI) / 2) {\n      tiltXrad = -Math.PI / 2;\n      tiltYrad = -Math.PI / 2;\n    }\n    if (azimuthAngle > (3 * Math.PI) / 2 && azimuthAngle < 2 * Math.PI) {\n      tiltXrad = Math.PI / 2;\n      tiltYrad = -Math.PI / 2;\n    }\n  }\n\n  if (altitudeAngle !== 0) {\n    const tanAlt = Math.tan(altitudeAngle);\n\n    tiltXrad = Math.atan(Math.cos(azimuthAngle) / tanAlt);\n    tiltYrad = Math.atan(Math.sin(azimuthAngle) / tanAlt);\n  }\n\n  const tiltX = Math.round(tiltXrad * radToDeg);\n  const tiltY = Math.round(tiltYrad * radToDeg);\n\n  return { tiltX, tiltY };\n}\n\nconst RNSVGElements = [\n  'Circle',\n  'ClipPath',\n  'Ellipse',\n  'ForeignObject',\n  'G',\n  'Image',\n  'Line',\n  'Marker',\n  'Mask',\n  'Path',\n  'Pattern',\n  'Polygon',\n  'Polyline',\n  'Rect',\n  'Svg',\n  'Symbol',\n  'TSpan',\n  'Text',\n  'TextPath',\n  'Use',\n];\n\n// This function helps us determine whether given node is SVGElement or not. In our implementation of\n// findNodeHandle, we can encounter such element in 2 forms - SVG tag or ref to SVG Element. Since Gesture Handler\n// does not depend on SVG, we use our simplified SVGRef type that has `elementRef` field. This is something that is present\n// in actual SVG ref object.\n//\n// In order to make sure that node passed into this function is in fact SVG element, first we check if its constructor name\n// corresponds to one of the possible SVG elements. Then we also check if `elementRef` field exists.\n// By doing both steps we decrease probability of detecting situations where, for example, user makes custom `Circle` and\n// we treat it as SVG.\nexport function isRNSVGElement(viewRef: SVGRef | GestureHandlerRef) {\n  const componentClassName = Object.getPrototypeOf(viewRef).constructor.name;\n\n  return (\n    RNSVGElements.indexOf(componentClassName) >= 0 &&\n    Object.hasOwn(viewRef, 'elementRef')\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}